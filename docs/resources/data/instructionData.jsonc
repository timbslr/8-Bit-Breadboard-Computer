{
  "$schema": "./instructionDataSchema.json",
  "instructions": [
    {
      "name": "add",
      "mnemonic": "add",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11010000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_A", "IE_F"], //calculate addition and output to register (works in one step because addition and subtraction is fast)
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 0,
      "shortDescription": "A = A + TMP",
      "longDescription": "The ADD instruction computes an addition on the A and B registers. These two operands are fixed and cannot be changed. What can be changed is the register in which the result is saved, it is specified as an operand of the instruction. After computation, the corresponding flags are set.",
      "examples": []
    },
    {
      "name": "add with immediate",
      "mnemonic": "addi",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "add"],
      "group": "ALU",
      "indexInGroup": 1,
      "shortDescription": "A = A + <imm>",
      "longDescription": "The ADDI instruction adds the specified immediate value to the A register. Internally, the instruction first loads the immediate into the TMP register and then performs a normal addition, which means that the TMP register will be overwritten by this instruction. Finally, the corresponding flags are set.",
      "examples": []
    },
    {
      "name": "add with carry",
      "mnemonic": "addc",
      "type": "REAL",
      "operands": [],
      "requiresFlag": true,
      "opcode": "00100100",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_A", "IE_F"], //if there's no carry, compute a normal addition
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_A", "IE_F"], //if there is a carry, add it to the result via ALU_CIN (Carry In)
          ["RSC"]
        ]
      },
      "group": "ALU",
      "indexInGroup": 2,
      "shortDescription": "A = A + TMP + CF",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "add with carry and immediate",
      "mnemonic": "addci",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "addc"],
      "group": "ALU",
      "indexInGroup": 2,
      "shortDescription": "A = A + <imm> + CF",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "subtract",
      "mnemonic": "sub",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11010100",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "OE_ALU", "IE_A", "IE_F"], //calculate subtraction and output to register (works in one step because addition and subtraction is fast)
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 3,
      "shortDescription": "A = A - TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "subtract with carry",
      "mnemonic": "subc",
      "type": "REAL",
      "operands": [],
      "requiresFlag": true,
      "opcode": "00101000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "OE_ALU", "IE_A", "IE_F"], //if carry is zero, a borrow occurred --> compute subtraction without ALU_CIN, resulting in decrementing the result by one
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "OE_ALU", "IE_A", "IE_F"], //if the carry is one, no borrow occurred --> adding ALU_CIN results in a normal subtraction
          ["RSC"]
        ]
      },
      "group": "ALU",
      "indexInGroup": 4,
      "shortDescription": "A = A - TMP - (1-CF)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "subtract with carry and immediate",
      "mnemonic": "subci",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "subc"],
      "group": "ALU",
      "indexInGroup": 2,
      "shortDescription": "A = A - <imm> - (1-CF)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"and\"",
      "mnemonic": "and",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11011000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_AND"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_AND", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 5,
      "shortDescription": "A = A & TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"and\" with immediate",
      "mnemonic": "andi",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "and"],
      "group": "ALU",
      "indexInGroup": 6,
      "shortDescription": "A = A & <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"or\"",
      "mnemonic": "or",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11011100",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_OR"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_OR", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 7,
      "shortDescription": "A = A | TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"or\" with immediate",
      "mnemonic": "ori",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "or"],
      "group": "ALU",
      "indexInGroup": 8,
      "shortDescription": "A = A | <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"exclusive or\"",
      "mnemonic": "xor",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "10110000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_XOR"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_XOR", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 9,
      "shortDescription": "A = A ^ TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"exclusive or\" with immediate",
      "mnemonic": "xori",
      "type": "PSEUDO",
      "operands": ["imm"],
      "mappedInstructions": ["li TMP, <imm>", "xor"],
      "group": "ALU",
      "indexInGroup": 10,
      "shortDescription": "A = A ^ <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "logic \"not\"",
      "mnemonic": "not",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11100100",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_NOT"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_NOT", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 11,
      "shortDescription": "A = ~A",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "negate",
      "mnemonic": "neg",
      "type": "PSEUDO",
      "operands": [],
      "mappedInstructions": ["not", "addi 1"],
      "group": "ALU",
      "indexInGroup": 12,
      "shortDescription": "A = ~A + 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "shift left",
      "mnemonic": "shl",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11001000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_A", "IE_TMP"],
        ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 13,
      "shortDescription": "A = A << 1 (zero-extended)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "shift logic right",
      "mnemonic": "slr",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11101100",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_SLR"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_SLR", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 14,
      "shortDescription": "A = A >> 1 (zero-extended)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "shift arithmetic right",
      "mnemonic": "sar",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "11110000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_SAR"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_SAR", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 15,
      "shortDescription": "A = A >> 1 (sign-extended)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "rotate right",
      "mnemonic": "ror",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "111101RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_ROR"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_ROR", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 16,
      "shortDescription": "A = rotate A right by one bit",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "rotate left",
      "mnemonic": "rol",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "111110RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["ALU_SRC_BIT", "ALU_BOP_ROL"], //compute the result beforehand as logic operations are too slow to be executed in a single microinstruction
        ["ALU_SRC_BIT", "ALU_BOP_ROL", "OE_ALU", "IE_A", "IE_F"], //let the ALU control signals unchanged and output result to register
        ["RSC"]
      ],
      "group": "ALU",
      "indexInGroup": 18,
      "shortDescription": "A = rotate A left by one bit",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "clear",
      "mnemonic": "clr",
      "type": "PSEUDO",
      "operands": ["reg"],
      "mappedInstructions": ["li <reg>, 0"],
      "group": "REG-MEM",
      "indexInGroup": 0,
      "shortDescription": "<reg> = 0",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "move",
      "mnemonic": "mov",
      "type": "REAL",
      "operands": ["regd", "regs"],
      "requiresFlag": false,
      "opcode": "1001RRRR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_<regs>", "IE_<regd>"], //move from source to destination register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 1,
      "shortDescription": "<regd> = <regs>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "move special",
      "mnemonic": "movs",
      "type": "REAL",
      "operands": ["regsd", "regss"],
      "requiresFlag": false,
      "opcode": "0111RRRR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_<regss>", "IE_<regsd>"], //only special combinations of non-standard registers are allowed here, the exact combinations are specified in movsData.json
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 1,
      "shortDescription": "<regsd> = <regss>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "load",
      "mnemonic": "ld",
      "type": "REAL",
      "operands": ["reg", "addr"],
      "requiresFlag": false,
      "opcode": "101011RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //           ──┐
        ["OE_PC_L", "IE_MAR_L"], //             ├──> Fetch first operand (= low byte of address) and move it into the buffer
        ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //             ──┐
        ["OE_PC_L", "IE_MAR_L"], //               ├──> Fetch second operand (= high byte of address) and move it into MAR_H
        ["MEM_EN_IO", "IE_MAR_H", "INC_PC"], // ──┘
        ["OE_BUF", "IE_MAR_L"], //move buffer value (= low byte of address) to MAR_L
        ["MEM_EN_IO", "IE_<reg>"], //read from memory at fetched address and move the result to the given register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 3,
      "shortDescription": "<reg> = mem[<addr>]",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "load with offset",
      "mnemonic": "ldo",
      "type": "REAL",
      "operands": ["reg", "addr"],
      "requiresFlag": true,
      "opcode": "001101RR",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch first operand (= low byte of address) and move it into the A-Register
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["OE_X", "IE_TMP"], //move X-Register to TMP-Register
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_BUF", "IE_F"], //add the low byte of the address to the offset (stored in the X-Register) and move result into Buffer-Register
          ["OE_PC_H", "IE_MAR_H"], //             ──┐
          ["OE_PC_L", "IE_MAR_L"], //               ├──> Fetch second operand (= high byte of address) and move it into MAR_H (--> No Carry occurred, so we can directly move the high byte of the address into MAR_H)
          ["MEM_EN_IO", "IE_MAR_H", "INC_PC"], // ──┘
          ["OE_BUF", "IE_MAR_L"], //computed address is now in MAR
          ["MEM_EN_IO", "IE_<reg>"], //read from memory at computed address and move the result to the given register
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch first operand (= low byte of address) and move it into the A-Register
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["OE_X", "IE_TMP"], //move X-Register to TMP-Register
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_BUF", "IE_F"], //add the low byte of the address to the offset (stored in the X-Register) and move result into Buffer-Register
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch second operand (= high byte of address) and move it into the A-Register (--> Carry occurred, so we have to increment the high byte of the address)
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["IE_TMP"], //set TMP-Register to 0 (works because of pull-down resistors on the bus)
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_MAR_H", "IE_F"], //add one to the high byte of the address (because a carry occurred)
          ["OE_BUF", "IE_MAR_L"], //computed address is now in MAR
          ["MEM_EN_IO", "IE_<reg>"], //read from memory at computed address and move the result to the given register
          ["RSC"]
        ]
      },
      "group": "REG-MEM",
      "indexInGroup": 4,
      "shortDescription": "<reg> = mem[<addr> + X]",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "store",
      "mnemonic": "st",
      "type": "REAL",
      "operands": ["reg", "addr"],
      "requiresFlag": false,
      "opcode": "101101RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //           ──┐
        ["OE_PC_L", "IE_MAR_L"], //             ├──> Fetch first operand (= low byte of address) and move it into the buffer
        ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //             ──┐
        ["OE_PC_L", "IE_MAR_L"], //               ├──> Fetch second operand (= high byte of address) and move it into MAR_H
        ["MEM_EN_IO", "IE_MAR_H", "INC_PC"], // ──┘
        ["OE_BUF", "IE_MAR_L"], //move buffer value (= low byte of address) to MAR_L
        ["MEM_EN_IO", "MEM_WE", "OE_<reg>"], //store the value of the given register into memory at the fetched address
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 5,
      "shortDescription": "mem[<addr>] = <reg>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "store with offset",
      "mnemonic": "sto",
      "type": "REAL",
      "operands": ["reg", "addr"],
      "requiresFlag": true,
      "opcode": "001110RR",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch first operand (= low byte of address) and move it into the A-Register
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["OE_X", "IE_TMP"], //move X-Register to TMP-Register
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_BUF", "IE_F"], //add the low byte of the address to the offset (stored in the X-Register) and move result into Buffer-Register
          ["OE_PC_H", "IE_MAR_H"], //             ──┐
          ["OE_PC_L", "IE_MAR_L"], //               ├──> Fetch second operand (= high byte of address) and move it into MAR_H (--> No Carry occurred, so we can directly move the high byte of the address into MAR_H)
          ["MEM_EN_IO", "IE_MAR_H", "INC_PC"], // ──┘
          ["OE_BUF", "IE_MAR_L"], //computed address is now in MAR
          ["MEM_EN_IO", "MEM_WE", "OE_<reg>"], //store the value of the given register into memory at the computed address
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch first operand (= low byte of address) and move it into the A-Register
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["OE_X", "IE_TMP"], //move X-Register to TMP-Register
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "OE_ALU", "IE_BUF", "IE_F"], //add the low byte of the address to the offset (stored in the X-Register) and move result into Buffer-Register
          ["OE_PC_H", "IE_MAR_H"], //         ──┐
          ["OE_PC_L", "IE_MAR_L"], //           ├──> Fetch second operand (= high byte of address) and move it into the A-Register (--> Carry occurred, so we have to increment the high byte of the address)
          ["MEM_EN_IO", "IE_A", "INC_PC"], // ──┘
          ["IE_TMP"], //set TMP-Register to 0 (works because of pull-down resistors on the bus)
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_MAR_H", "IE_F"], //add one to the high byte of the address (because a carry occurred)
          ["OE_BUF", "IE_MAR_L"], //computed address is now in MAR
          ["MEM_EN_IO", "MEM_WE", "OE_<reg>"], //store the value of the given register into memory at the computed address
          ["RSC"]
        ]
      },
      "group": "REG-MEM",
      "indexInGroup": 6,
      "shortDescription": "mem[<addr> + X] = <reg>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "load from stack",
      "mnemonic": "lds",
      "type": "REAL",
      "operands": ["reg"],
      "requiresFlag": false,
      "opcode": "101110RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_SP_H", "IE_MAR_H"], // ──┬──> Move SP into MAR
        ["OE_SP_L", "IE_MAR_L"], // ──┘
        ["MEM_EN_IO", "IE_<reg>"], //read from memory at current SP address and move the value into the specified register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 7,
      "shortDescription": "<reg> = mem[SP]",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "store to stack",
      "mnemonic": "sts",
      "type": "REAL",
      "operands": ["reg"],
      "requiresFlag": false,
      "opcode": "101111RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_SP_H", "IE_MAR_H"], // ──┬──> Move SP into MAR
        ["OE_SP_L", "IE_MAR_L"], // ──┘
        ["MEM_EN_IO", "MEM_WE", "OE_<reg>"], //store value from given register into memory at address of SP
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 8,
      "shortDescription": "mem[SP] = <reg>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "load immediate",
      "mnemonic": "li",
      "type": "REAL",
      "operands": ["reg", "imm"],
      "requiresFlag": false,
      "opcode": "101010RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //             ──┐
        ["OE_PC_L", "IE_MAR_L"], //               ├──> Fetch Operand (= immediate) and move into the specified register
        ["MEM_EN_IO", "IE_<reg>", "INC_PC"], // ──┘
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 9,
      "shortDescription": "<reg> = <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "push to stack",
      "mnemonic": "push",
      "type": "PSEUDO",
      "operands": ["reg"],
      "mappedInstructions": ["sts <reg>", "incsp"],
      "group": "REG-MEM",
      "indexInGroup": 10,
      "shortDescription": "mem[SP] = <reg>\nSP = SP + 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "pop from stack",
      "mnemonic": "pop",
      "type": "PSEUDO",
      "operands": ["reg"],
      "mappedInstructions": ["decsp", "lds <reg>"],
      "group": "REG-MEM",
      "indexInGroup": 11,
      "shortDescription": "SP = SP - 1\n<reg> = mem[SP]",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "peek at stack",
      "mnemonic": "peek",
      "type": "PSEUDO",
      "operands": ["reg"],
      "mappedInstructions": ["pop <reg>", "incsp"],
      "group": "REG-MEM",
      "indexInGroup": 12,
      "shortDescription": "<reg> = mem[SP]",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "increment X-Register",
      "mnemonic": "incx",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "01100100",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["INC_X"], //increment the X-Register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 13,
      "shortDescription": "X= X + 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "increment Y-Register",
      "mnemonic": "incy",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "01100110",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["INC_Y"], //increment the Y-Register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 13,
      "shortDescription": "Y = Y + 1",
      "longDescription": "",
      "examples": [
        //TODO
      ]
    },
    {
      "name": "increment stack-pointer",
      "mnemonic": "incsp",
      "type": "REAL",
      "operands": [],
      "requiresFlag": true,
      "opcode": "00110000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_SP_L", "IE_A"], //move SP_L to A-Register
          ["IE_TMP"], //set TMP-Register to 0 (works because of pull-down resistors on the bus)
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_SP_L", "IE_F"], //add one to SP_L by using ALU_CIN as the source for a "1"
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_SP_L", "IE_A"], //move SP_L to A-Register
          ["IE_TMP"], //set TMP-Register to 0 (works because of pull-down resistors on the bus)
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_SP_L", "IE_F"], //add one to SP_L by using ALU_CIN as the source for a "1"
          ["OE_SP_H", "IE_A"], //move SP_H to A-Register
          ["IE_TMP"], //set TMP-Register to 0 (works because of pull-down resistors on the bus)
          ["ALU_SRC_ARI", "ALU_AOP_ADD", "ALU_CIN", "OE_ALU", "IE_SP_H", "IE_F"], //add one to SP_H as carry occurred
          ["RSC"]
        ]
      },
      "group": "REG-MEM",
      "indexInGroup": 14,
      "shortDescription": "SP = SP + 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "increment value in memory",
      "mnemonic": "incm",
      "type": "PSEUDO",
      "operands": ["addr"],
      "mappedInstructions": ["ld X, <addr>", "incx", "st X, <addr>"],
      "group": "REG-MEM",
      "indexInGroup": 15,
      "shortDescription": "mem[<addr>] = mem[<addr>] + 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "decrement X-Register",
      "mnemonic": "decx",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "01100101",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["DEC_X"], //decrement the X-Register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 16,
      "shortDescription": "X = X - 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "decrement Y-Register",
      "mnemonic": "decy",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "01100111",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["DEC_Y"], //decrement the X-Register
        ["RSC"]
      ],
      "group": "REG-MEM",
      "indexInGroup": 16,
      "shortDescription": "Y = Y - 1",
      "longDescription": "",
      "examples": [
        //TODO
      ]
    },
    {
      "name": "decrement stack-pointer",
      "mnemonic": "decsp",
      "type": "REAL",
      "operands": [],
      "requiresFlag": true,
      "opcode": "00110001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_SP_L", "IE_A"], //move SP_L to A-Register
          ["IE_TMP"],
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "OE_ALU", "IE_SP_L", "IE_F"], //without an ALU_CIN, its automatically an addition with -1
          ["OE_SP_H", "IE_A"],
          ["IE_TMP"],
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "OE_ALU", "IE_SP_H", "IE_F"],
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_SP_L", "IE_A"], //move SP_L to A-Register
          ["IE_TMP"],
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "OE_ALU", "IE_SP_L", "IE_F"], //without an ALU_CIN, its automatically an addition with -1
          ["RSC"]
        ]
      },
      "group": "REG-MEM",
      "indexInGroup": 14,
      "shortDescription": "SP = SP - 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "decrement value in memory",
      "mnemonic": "decm",
      "type": "PSEUDO",
      "operands": ["addr"],
      "mappedInstructions": ["ld X, <addr>", "decx", "st X, <addr>"],
      "group": "REG-MEM",
      "indexInGroup": 18,
      "shortDescription": "mem[<addr>] = mem[<addr>] - 1",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "output to 7-segment display",
      "mnemonic": "out7sd",
      "type": "REAL",
      "operands": ["reg"],
      "requiresFlag": false,
      "opcode": "000111RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_<reg>", "IE_7SD"], //load value from specified register into 7-Segment Display
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 0,
      "shortDescription": "Outputs the value in the given register to the 7-segment display",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "set 7-segment display signed mode",
      "mnemonic": "s7sdsm",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "00000010",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["7SD_SM"], //activate 7-Segment Display signed mode
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 0,
      "shortDescription": "Sets the 7-segment display into signed mode (values -128 to 127)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "set 7-segment display unsigned mode",
      "mnemonic": "s7sdum",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "00000011",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["7SD_UM"], //activate 7-Segment Display unsigned mode
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 0,
      "shortDescription": "Sets the 7-segment display into unsigned mode (values 0 to 255)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "output immediate to 7-segment display",
      "mnemonic": "out7sdi",
      "type": "REAL",
      "operands": ["imm"],
      "requiresFlag": false,
      "opcode": "00001111",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //           ──┐
        ["OE_PC_L", "IE_MAR_L"], //             ├──> Fetch Operand (= immediate) and move it to the 7-Segment Display
        ["MEM_EN_IO", "IE_7SD", "INC_PC"], // ──┘
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 1,
      "shortDescription": "Outputs the value in the given register to the 7-segment display",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "output to lcd",
      "mnemonic": "outlcd",
      "type": "REAL",
      "operands": ["lcdreg", "reg"],
      "requiresFlag": false,
      "opcode": "01001LRR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_<reg>", "LCD_WRITE", "LCD_<lcdreg>", "LCD_E"], //enables writing, selects the specified LCD-Register (DATA or CONTROL) and creates a short pulse at the enable-line
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 2,
      "shortDescription": "Outputs the value in the given register to the LCD (either as CTRL or DATA, depending on <lcdreg>)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "output immediate to lcd",
      "mnemonic": "outlcdi",
      "type": "REAL",
      "operands": ["lcdreg", "imm"],
      "requiresFlag": false,
      "opcode": "0100011L",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //                                       ──┐
        ["OE_PC_L", "IE_MAR_L"], //                                         ├──> Fetch Operand (= immediate) and send it to the lcd by enabling write, selecting the specified LCD-Register (DATA or CONTROL) and creating a short pulse at the enable-line
        ["MEM_EN_IO", "LCD_WRITE", "LCD_<lcdreg>", "LCD_E", "INC_PC"], // ──┘
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 3,
      "shortDescription": "Outputs an immediate to the LCD (either as CTRL or DATA, depending on <lcdreg>)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "lcd read",
      "mnemonic": "lcdrd",
      "type": "REAL",
      "operands": ["lcdreg", "reg"],
      "requiresFlag": false,
      "opcode": "01011LRR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["IE_<reg>", "LCD_READ", "LCD_<lcdreg>", "LCD_E"],
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 4,
      "shortDescription": "Reads from the LCD (either from CTRL or DATA register, depending on <lcdreg>) into the given register",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "serial rx read",
      "mnemonic": "rxrd",
      "type": "REAL",
      "operands": ["reg"],
      "requiresFlag": false,
      "opcode": "010100RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["IE_<reg>", "OE_SER_RX"],
        ["SER_RX_CONS"], // tell the rx module that the received byte has been consumed, which resets the SER_RX_RDY flag
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 5,
      "shortDescription": "Moves the byte from the rx shift-register of the serial interface module into one of the standard registers and resets the SER_RX_RDY flag",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "serial tx send",
      "mnemonic": "txsend",
      "type": "REAL",
      "operands": ["reg"],
      "requiresFlag": false,
      "opcode": "010101RR",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_<reg>", "SER_RX_SEND"],
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 6,
      "shortDescription": "",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "serial tx send immediate",
      "mnemonic": "txsendi",
      "type": "REAL",
      "operands": ["imm"],
      "requiresFlag": false,
      "opcode": "01000010",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //                ──┐
        ["OE_PC_L", "IE_MAR_L"], //                  ├──> Fetch Operand (= immediate) and send it to the lcd by enabling write, selecting the specified LCD-Register (DATA or CONTROL) and creating a short pulse at the enable-line
        ["MEM_EN_IO", "SER_RX_SEND", "INC_PC"], // ──┘
        ["RSC"]
      ],
      "group": "I-O",
      "indexInGroup": 6,
      "shortDescription": "",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "no operation",
      "mnemonic": "nop",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "00000000",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["RSC"]
      ],
      "group": "SYS",
      "indexInGroup": 0,
      "shortDescription": "Does nothing for 3 clock cycles",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "halt",
      "mnemonic": "hlt",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "00000001",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["HALT"], //halts the computer by stopping the clock
        ["RSC"]
      ],
      "group": "SYS",
      "indexInGroup": 1,
      "shortDescription": "Halts the entire computer. This instruction is called at the end of a program.",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "call subroutine",
      "mnemonic": "call",
      "type": "PSEUDO",
      "operands": ["addr"],
      "mappedInstructions": [
        "li TMP, nextInstructionAddress[15:8]",
        "push TMP",
        "li TMP, nextInstructionAddress[7:0]",
        "push TMP",
        "jmp {addr}"
      ],
      "group": "SYS",
      "indexInGroup": 2,
      "shortDescription": "Calls the subroutine placed at the given address",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "return from subroutine",
      "mnemonic": "ret",
      "type": "PSEUDO",
      "operands": [],
      "mappedInstructions": ["pop TMP", "movs BUF, TMP", "pop TMP", "jmpr"],
      "group": "SYS",
      "indexInGroup": 3,
      "shortDescription": "Returns from a function call",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "jump",
      "mnemonic": "jmp",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": false,
      "opcode": "00000101",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //           ──┐
        ["OE_PC_L", "IE_MAR_L"], //             ├──> Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
        ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
        ["OE_PC_H", "IE_MAR_H"], //           ──┐
        ["OE_PC_L", "IE_MAR_L"], //             ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
        ["MEM_EN_IO", "IE_PC_H"], //          ──┘
        ["OE_BUF", "IE_PC_L"], //move buffer value (= low byte of address to jump to) to PC_L
        ["RSC"]
      ],
      "group": "BR-JMP",
      "indexInGroup": 0,
      "shortDescription": "PC = <addr>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "jump register",
      "mnemonic": "jmpr",
      "type": "REAL",
      "operands": [],
      "requiresFlag": false,
      "opcode": "00000110",
      "microinstructions": [
        ["OE_PC_H", "IE_MAR_H"], //          ──┐
        ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
        ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
        ["OE_A", "IE_PC_L"], //          ──┐
        ["OE_TMP", "IE_PC_H"], //        ──┴──> Set PC to values in A- and TMP-Register (low and high address byte)
        ["RSC"]
      ],
      "group": "BR-JMP",
      "indexInGroup": 1,
      "shortDescription": "PC_L = A, PC_H = TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if equal",
      "mnemonic": "beq",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00010000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 2,
      "shortDescription": "branch if A == TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if equal to immediate",
      "mnemonic": "beqi",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "beq <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 3,
      "shortDescription": "branch if A == <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if not equal",
      "mnemonic": "bne",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00010001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 4,
      "shortDescription": "branch if A == TMP",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if not equal to immediate",
      "mnemonic": "bnei",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bne <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 5,
      "shortDescription": "branch if A != <imm>",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less than",
      "mnemonic": "blt",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "10000000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 6,
      "shortDescription": "branch if A < TMP (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less than immediate",
      "mnemonic": "blti",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "blt <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 7,
      "shortDescription": "branch if A < <imm> (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less than unsigned",
      "mnemonic": "bltu",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00100010",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 8,
      "shortDescription": "branch if A < TMP (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less than immediate unsigned",
      "mnemonic": "bltiu",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bltu <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 9,
      "shortDescription": "branch if A < <imm> (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less or equal",
      "mnemonic": "ble",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "10100000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 10,
      "shortDescription": "branch if A <= TMP (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less or equal immediate",
      "mnemonic": "blei",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "ble <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 11,
      "shortDescription": "branch if A <= <imm> (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less or equal unsigned",
      "mnemonic": "bleu",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11000000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 12,
      "shortDescription": "branch if A <= TMP (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if less or equal immediate unsigned",
      "mnemonic": "bleiu",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bleu <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 13,
      "shortDescription": "branch if A <= <imm> (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater or equal",
      "mnemonic": "bge",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "10000001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 14,
      "shortDescription": "branch if A >= TMP (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater or equal immediate",
      "mnemonic": "bgei",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bge <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 15,
      "shortDescription": "branch if A >= <imm> (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater or equal unsigned",
      "mnemonic": "bgeu",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00100011",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it into PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 16,
      "shortDescription": "branch if A >= TMP (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater or equal immediate unsigned",
      "mnemonic": "bgeiu",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bgeu <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 17,
      "shortDescription": "branch if A >= <imm> (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater than",
      "mnemonic": "bgt",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "10100001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 18,
      "shortDescription": "branch if A > TMP (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater than immediate",
      "mnemonic": "bgti",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bgt <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 19,
      "shortDescription": "branch if A > <imm> (signed)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater than unsigned",
      "mnemonic": "bgtu",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11000001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to P_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["ALU_SRC_ARI", "ALU_AOP_SUB", "ALU_CIN", "IE_F"], //normal subtraction to check if the computer should branch or not
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 20,
      "shortDescription": "branch if A > TMP (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if greater than immediate unsigned",
      "mnemonic": "bgtiu",
      "type": "PSEUDO",
      "operands": ["imm", "addr"],
      "mappedInstructions": ["li TMP, <imm>", "bgtu <addr>"],
      "group": "BR-JMP",
      "indexInGroup": 21,
      "shortDescription": "branch if A > <imm> (unsigned)",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if zero set",
      "mnemonic": "bzs",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00001000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 22,
      "shortDescription": "branch if branch if ZF is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if zero clear",
      "mnemonic": "bzc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00001001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 23,
      "shortDescription": "branch if ZF is not set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if carry set",
      "mnemonic": "bcs",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00100000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 24,
      "shortDescription": "branch if CF is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if carry clear",
      "mnemonic": "bcc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "00100001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 25,
      "shortDescription": "branch if CF is not set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if negative set",
      "mnemonic": "bns",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "01000000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 26,
      "shortDescription": "branch if NF is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if negative clear",
      "mnemonic": "bnc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "01000001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 27,
      "shortDescription": "branch if NF is not set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if overflow set",
      "mnemonic": "bvs",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "01100000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 28,
      "shortDescription": "branch if VF is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if overflow clear",
      "mnemonic": "bvc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "01100001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 29,
      "shortDescription": "branch if VF is not set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if serial-rx-ready set",
      "mnemonic": "brxrdys",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11100000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 30,
      "shortDescription": "branch if serial-rx-ready flag is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if serial-rx-ready clear",
      "mnemonic": "brxrdyc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11100001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 31,
      "shortDescription": "branch if serial-rx-ready flag is not set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if serial-tx-ready set",
      "mnemonic": "btxrdys",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11101000",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 32,
      "shortDescription": "branch if serial-tx-ready flag is set",
      "longDescription": "",
      "examples": []
    },
    {
      "name": "branch if serial-tx-ready clear",
      "mnemonic": "btxrdyc",
      "type": "REAL",
      "operands": ["addr"],
      "requiresFlag": true,
      "opcode": "11101001",
      "microinstructions": {
        "0": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //           ──┐
          ["OE_PC_L", "IE_MAR_L"], //             ├──> Branch occurs: Fetch first Operand (= low byte of the address to jump to) and move it into the buffer
          ["MEM_EN_IO", "IE_BUF", "INC_PC"], // ──┘
          ["OE_PC_H", "IE_MAR_H"], //  ──┐
          ["OE_PC_L", "IE_MAR_L"], //    ├──> Fetch second Operand (= high byte of the address to jump to) and move it to PC_H
          ["MEM_EN_IO", "IE_PC_H"], // ──┘
          ["OE_BUF", "IE_PC_L"], //move BUF to PC_L
          ["RSC"]
        ],
        "1": [
          ["OE_PC_H", "IE_MAR_H"], //          ──┐
          ["OE_PC_L", "IE_MAR_L"], //            ├──> Fetch Opcode
          ["MEM_EN_IO", "IE_IR", "INC_PC"], // ──┘
          ["INC_PC"], //  ──┐
          ["INC_PC"], //  ──┴──> skip the two address bytes as there is no branch
          ["RSC"]
        ]
      },
      "group": "BR-JMP",
      "indexInGroup": 33,
      "shortDescription": "branch if serial-tx-ready flag is not set",
      "longDescription": "",
      "examples": []
    }
  ]
}
